<link rel="import" href="../uva-helper-libs/lodash.html">

<script>
    /**
     * The Mixin for a form field.
     * Contains properties and methods associated with displaying form inputs.
     *
     * @polymerMixin
     */
    UvalibField = Polymer.dedupingMixin(function(superClass) {
      return class extends superClass {
        constructor() {
          super();
        }
        static get properties() {
          return {
            tabindex: {
              type: Number,
              value: 0
            },
            /**
             * The form field element.
             */
            element: {
              type: Object,
              notify: true
            },
            value: {
              type: String,
              notify: true,
              reflectToAttribute: true
            },
            invalidValues: {
              type: Boolean,
              value: false,
              notify: true
            },
            _ariaInvalid: {
              type: Boolean,
              computed: "_isInvalidValue(invalidValues,element)"
            }
          };
        }

        focus() {
          this.shadowRoot.querySelector('input, select, textarea').focus();
        }

        _isInvalidValue(invalidValues,element) {
          console.log('invalidValues: '+invalidValues);
          if (element.name) {
            console.log(element.name+' valid? '+element.valid);
          } else {
            console.log(element.type+' valid?'+element.valid);
          }
          console.log('_isInvalidValue: '+ (invalidValues && !element.valid));
          return invalidValues && !element.valid;
        }

        _changedValue(e) {
          //console.log('changed value');
          // @TODO need to determine how to get accurate value for a checkbox input field.
          this.value = this.shadowRoot.querySelector('#'+this.element.webform_key).value;
          //console.log(this.value);
          this.dispatchEvent(new CustomEvent('changedValue', {detail: {field_id: this.element.webform_key}, bubbles: true, composed: true}));
        }

        _hasDescription(el) {
          return (el.description && el.description.markup && el.description.markup!='');
        }

        _isRequired(el) {
          return el.required || (el.required_error && el.required_error != "");
        }

        /**
         * The field needs to be visually flagged as required.
         */
        required() {

        }
      }
    });
  </script>
