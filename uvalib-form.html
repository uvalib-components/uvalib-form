<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../uvalib-account/uvalib-account-auth.html">
<link rel="import" href="../uva-models/uva-library.html">
<link rel="import" href="../uvalib-theme/uvalib-theme.html">

<dom-module id="uvalib-form">
  <template>
    <style>
      :host {
        display: block;
      }
      .text-block {

      }
      .section {
        padding-top: 1rem;
      }
      fieldset {
        padding: 10px 0px;
        border: none;
      }
      legend {
        padding: 0px;
        font: 1.5rem bold serif;
      }
      .form-field {
        padding: 10px 0px 10px 0px;
      }
      label {
        display: block;
        font-weight: bold;
        padding-bottom: 5px;
      }
      .required {
        padding-left: 5px;
        color: var(--uvalib-main-rotunda-orange);
      }
      paper-button {
        border: 1px solid black;
      }
    </style>

    <uva-library path="web/forms" items="{{formPage}}" filter="{{_formFilter}}"></uva-library>

    <template is="dom-if" if="{{_authenticated}}"><uvalib-account-auth user="{{userInfo}}"></uvalib-account-auth></template>
    <form method="post" action="{{_confirmationPagePath}}">
      <input type="hidden" name="[[formId]]" />
      <template is="dom-repeat" items="{{_elements}}" as="elem">
        <template is="dom-if" if="{{_isFieldset(elem)}}">
          <template is="dom-if" if="{{_inFieldset}}">
            </fieldset>
          </div>
          </template>
          <template is="dom-if" if="[[_showFieldSet(elem,_ping)]]">
            <div class="section">
              <fieldset>
                <legend>{{elem.title}}</legend>
                  <template is="dom-repeat" items="{{_getFieldSetElements(elem)}}" as="fldset_elem">
                    <template is="dom-if" if="{{_isMarkup(fldset_elem)}}">
                      <template is="dom-if" if="[[_showMarkup(fldset_elem,_ping)]]">
                        <div class="text-block" inner-h-t-m-l="{{fldset_elem.markup}}"></div>
                      </template>
                    </template>
                    <template is="dom-if" if="{{_isField(fldset_elem)}}">
                      <template is="dom-if" if="[[_showField(fldset_elem,_ping)]]">
                        <div class="form-field">
                          <label for="{{fldset_elem.name}}">{{fldset_elem.title}}<template is="dom-if" if="{{_isRequired(fldset_elem)}}"><span class="required">*</span></template></label>
                          <template is="dom-if" if="{{_hasDescription(fldset_elem)}}">
                            <div class="descriptive-text">{{fldset_elem.description.markup}}</div>
                          </template>
                          <template is="dom-if" if="{{_isSelect(fldset_elem)}}">
                            <select id="{{fldset_elem.name}}" required="{{_isRequired(fldset_elem)}}" value="{{fldset_elem.value::change}}" on-change="_pingIt">
                              <template is="dom-repeat" items="{{_getArray(fldset_elem.options)}}" as="fldset_option">
                                <template is="dom-if" if="{{_isValidOption(fldset_option)}}">
                                  <template is="dom-if" if="{{_selectedValue(fldset_elem,fldset_option)}}"><option selected value="{{fldset_option}}">{{fldset_option}}</option></template>
                                  <template is="dom-if" if="{{!_selectedValue(fldset_elem,fldset_option)}}"><option value="{{fldset_option}}">{{fldset_option}}</option></template>
                                </template>
                              </template>
                            </select>
                          </template>
                          <template is="dom-if" if="{{_isInput(fldset_elem)}}">
                            <input type="{{fldset_elem.type}}" id="{{fldset_elem.name}}" size="{{fldset_elem.size}}" required="{{_isRequired(fldset_elem)}}" value=""></input>
                          </template>
                          <template is="dom-if" if="{{_isCheckbox(fldset_elem)}}">
                            <input type="{{fldset_elem.type}}" id="{{fldset_elem.name}}" required="{{_isRequired(fldset_elem)}}" value=""></input>
                          </template>
                          <template is="dom-if" if="{{_isTextArea(fldset_elem)}}">
                            <textarea id="{{fldset_elem.name}}" rows="{{fldset_elem.rows}}" cols="{{fldset_elem.cols}}" required="{{_isRequired(fldset_elem)}}" value=""></textarea>
                          </template>
                        </div>
                      </template>
                    </template>
                  </template>
          </template>
        </template>
        <template is="dom-if" if="{{!_isFieldset(elem)}}">
          <template is="dom-if" if="{{_isMarkup(elem)}}">
            <template is="dom-if" if="[[_showMarkup(elem,_ping)]]">
              <div class="text-block" inner-h-t-m-l="{{elem.markup}}"></div>
            </template>
          </template>
          <template is="dom-if" if="{{_isField(elem)}}">
            <template is="dom-if" if="[[_showField(elem,_ping)]]">
              <div class="form-field">
                <label for="{{elem.name}}">{{elem.title}}<template is="dom-if" if="{{_isRequired(elem)}}"><span class="required">*</span></template></label>
                <template is="dom-if" if="{{_hasDescription(elem)}}">
                  <div class="descriptive-text">{{elem.description.markup}}</div>
                </template>
                <template is="dom-if" if="{{_isSelect(elem)}}">
                  <select id="{{elem.name}}" required="{{_isRequired(elem)}}" value="{{elem.value::change}}" on-change="_pingIt">
                    <template is="dom-repeat" items="{{_getArray(elem.options)}}" as="option">
                      <template is="dom-if" if="{{_isValidOption(option)}}">
                        <template is="dom-if" if="{{_selectedValue(elem,option)}}"><option selected value="{{option}}">{{option}}</option></template>
                        <template is="dom-if" if="{{!_selectedValue(elem,option)}}"><option value="{{option}}">{{option}}</option></template>
                      </template>
                    </template>
                  </select>
                </template>
                <template is="dom-if" if="{{_isInput(elem)}}">
                  <input type="{{elem.type}}" id="{{elem.name}}" size="{{elem.size}}" required="{{_isRequired(elem)}}" value=""></input>
                </template>
                <template is="dom-if" if="{{_isCheckbox(elem)}}">
                  <input type="{{elem.type}}" id="{{elem.name}}" required="{{_isRequired(elem)}}" value=""></input>
                </template>
                <template is="dom-if" if="{{_isTextArea(elem)}}">
                  <textarea id="{{elem.name}}" rows="{{elem.rows}}" cols="{{elem.cols}}" required="{{_isRequired(elem)}}" value=""></textarea>
                </template>
              </div>
            </template>
          </template>
        </template>
        <template is="dom-if" if="{{_isSubmit(elem)}}">
          </fieldset>
          <template is="dom-if" if="{{_showSubmit(elem)}}">
            <input type="{{elem.submit.type}}" value="{{elem.submit.value}}"/>
          </template>
        </template>
      </template>
      <template is="dom-if" if="{{_noSubmitButton}}">
        </fieldset>
        <input type="submit" value="Submit"/>
      </template>
    </form>

  </template>

  <script>
    /**
     * `uvalib-form`
     * Component that builds out a web form UI using a form definition via the API.
     *
     * @TODO Need to utilize the states property to address showing/hiding elements as needed.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     * @demo demo/purchase-request.html
     */
    class UvalibForm extends Polymer.Element {
      static get is() { return 'uvalib-form'; }
      static get properties() {
        return {
          /**
           * User name, email address, department, etc. for use in pre-populating some information.
           */
          userInfo: {
            type: Object,
            value: function() { return {name: "Jack Kelly", emailAddress: "jkelly@virginia.edu", phone: "434-924-7119", affiliation: "Staff", departmentOrSchool: "UVA Library"}; }
          },
          /**
           * Used to indicate which workflow the server should use when processing the request submitted.
           */
          formId: {
            type: String
          },
          /**
           * An array containing the form page returned for the specified form id.
           */
          formPage: {
            type: Array,
            notify: true
          },
          /**
           * Filter for the uva library api call to select only the form id requested.
           */
          _formFilter: {
            type: Object,
            computed: '_filter(formId)'
          },
          /**
           * The form object from the page.
           */
          _elements: {
            type: Array,
            computed: '_parsePageForm(formPage)'
          },
          _authenticated: {
            type: Boolean,
            computed: '_isFormAuthenticated(_elements)'
          },
          _confirmationPagePath: {
            type: String,
            computed: '_getConfirmationPagePath(_elements)'
          },
          _inFieldset: {
            type: Boolean,
            value: false
          },
          _noSubmitButton: {
            type: Boolean,
            value: true
          },
          _ping: {
            type: Boolean,
            value: false
          }
        };
      }

      _pingIt(_ping) {
        this._ping = !this._ping;
      }
      _showFieldSet(item){
        if (!item.states) return true;
        else if (item.states && item.states.visible) {
          return this._testState(item.states.visible);
        }
      }
      _showMarkup(item){
        var isMarkup = item.type && item.type === "webform_markup";
        if (!isMarkup) return false;
        else if (!item.states) return true;
        else if (item.states && item.states.visible) {
          return this._testState(item.states.visible);
        }
      }
      _showSubmit(item){
        var isSubmit = item.type && item.type === "webform_actions";
        if (!isSubmit) return false;
        else if (!item.states) return true;
        else if (item.states && item.states.visible) {
          return this._testState(item.states.visible);
        }
      }
      _showField(item){
        if (!item.states) return true;
        else if (item.states && item.states.visible) {
          return this._testState(item.states.visible);
        }
      }
      _testState(state){
        //console.log("state test:");
        //console.log(state);
        if (Array.isArray(state)) {
          for (var i=0; i<state.length; i=i+2) {
            if (this._testField(state[i])) return true;
          }
          return false;
        } else {
          return this._testField(state);
        }
      }
      _testField(state){
        var test = true;
        // very error prone test - assuming much
        for (var key in state) {
          var id = key.replace(/.*"(.*)".*/,"$1"),
              val = state[key].value;
          if (!this.shadowRoot.querySelector('#'+id) || this.shadowRoot.querySelector('#'+id).value != val) {
            test = false; break;
          }
        }
        return test;
      }

      /**
       * Filter API web forms to get the one needed.
       * @return Object
       */
      _filter(id) {
        return {'target_id': id};
      }

      /**
       * Check authenticated field value to determine if form requires NetBadge.
       * @return Boolean
       */
      _isFormAuthenticated(els) {
        let auth = _.find(els, {title: 'authenticated'});
        return (auth.value == "yes") ? true : false;
      }

      _isRequired(el) {
        return el.required || (el.required_error && el.required_error != "");
      }
      _isMarkup(el) {
        return (el.type && el.type == "webform_markup") ? true : false;
      }
      _isSelect(el) {
        return (el.type && el.type=="select") ? true : false;
      }
      _isField(el) {
        return (el.type && (el.type=="email" || el.type=="tel" || el.type=="text" || el.type=="select" || el.type=="textarea" || el.type=="checkbox"))
      }
      _isInput(el) {
        return (el.type && (el.type=="email" || el.type=="tel" || el.type=="text"))
      }
      _isCheckbox(el) {
        return (el.type && el.type=="checkbox")
      }
      _hasDescription(el) {
        return (el.description && el.description.markup && el.description.markup!='');
      }
/*      _isEmail(el) {
        return (el.type && el.type=="email") ? true : false;
      }
      _isPhone(el) {
        return (el.type && el.type=="tel") ? true : false;
      }
      _isText(el) {
        return (el.type && el.type=="text") ? true : false;
      }*/
      _isTextArea(el) {
        return (el.type && el.type=="textarea") ? true : false;
      }
      _isSubmit(el) {
        if (el.type && el.type=="webform_actions") {
          this._noSubmitButton = false;
          return true;
        } else {
          return false;
        }
      }
      _isFieldset(el) {
        this._inFieldset = true;
        return (el.type && el.type=="fieldset") ? true : false;
      }
      _isValidOption(value) {
        return (value != '- Select -') ? true : false;
      }
      // Loop through the fieldset object key values and just examine the ones with
      // fld, mkup, fldset, ???
      _getFieldSetElements(el) {
        let fields = Array();
        for (var key in el) {
          if (key.match(/^fld\_|mkup\_|actions/)) {
            fields.push(el[key]);
            if (el[key].type && el[key].type == 'textfield') {
              el[key].type = 'text';
            }
          }
        }
        console.log(fields);
        return fields;
      }

      _getArray(obj) {
        console.log(_.values(obj));
        return _.values(obj);
      }
      /**
       * Get the path for the confirmation page.
       * @return String
       */
      _getConfirmationPagePath(els) {
        let path = _.find(els, {title: 'confirmation page path'});
        return path.value;
      }

      /**
       * Returns web form definition for the form page object.
       * @return Array
       */
      _parsePageForm(frmPg) {
        var fields = Array();
        if (frmPg) {
          var form = JSON.parse(frmPg[0].webform);
          for (var key in form) {
            if (key.match(/^fld\_|fldset\_|mkup\_|authenticated|confirmation|actions/)) {
              fields.push(form[key]);
              if (form[key].type && form[key].type == 'textfield') {
                form[key].type = 'text';
              }
            }
          }
        }
        console.log(fields);
        return fields;
      }

      _selectedValue(el,option) {
        return (el.default_value && el.default_value==option);
      }

/*      _generateMarkup(el) {
        var markup = '';
        if (el.name && el.name.match(/^fld\_/)) {
          if (el.type && el.type == 'webform_markup') {
            markup += '<div class="text-block">'+el.markup+'</div>';
          } else if (el.type && el.type == 'webform_actions') {
            // @TODO should this be handled differently?
          } else {
            markup += '<label for="'+el.name+'">'+el.title;
            markup += this._isRequired(el) ? '<span class="required">*</span>' : '';
            markup += '</label>';
            if ((el.type && el.type == 'email') || (el.type && el.type == 'tel') || (el.type && el.type == 'text'))  {
              markup += '<input type="'+el.type+'" id="'+el.name+'" size="'+el.size+'" error-message="'+el.required_error+'"';
              markup += this._isRequired(el) ? ' required' : '';
              markup += '></input>';
            } else if (el.type && el.type == 'textarea') {
              markup += '<textarea id="'+el.name+'" rows="'+el.rows+'" cols="'+el.cols+'" error-message="'+el.required_error+'"';
              markup += this._isRequired(el) ? ' required' : '';
              markup += '></textarea>';
            } else if (el.type && el.type == 'checkbox') {
              // @TODO Review a form to see what the Drupal content generates.
            } else if (el.type && el.type == 'select') {
              markup += '<select id="'+el.name+'"';
              markup += this._isRequired(el) ? ' required' : '';
              markup += '>';
              for (var key in el.options) {
                if (el.options[key] != '- Select -') {
                  markup += '<option value="'+key+'"';
                  markup += (el.default_value == key) ? ' selected' : '';
                  markup += '>'+el.options[key]+'</option>';
                }
              }
              markup += '</select>';
            }
          }
        }
        return markup;
      }*/

    }

    window.customElements.define(UvalibForm.is, UvalibForm);
  </script>
</dom-module>
